
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import { prisma } from '@/lib/db';

/**
 * POST /api/auto-content/generate-topics
 * Generate topics based on niche and subscription
 */
export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const client = await prisma.client.findUnique({
      where: { email: session.user.email },
      include: {
        ClientSubscription: {
          include: {
            Package: true,
          },
        },
      },
    });

    if (!client) {
      return NextResponse.json({ error: 'Client not found' }, { status: 404 });
    }

    const data = await request.json();
    const { niche, count } = data;

    if (!niche) {
      return NextResponse.json({ error: 'Niche is required' }, { status: 400 });
    }

    // Get client's subscription to determine how many articles per month
    const subscription = client.ClientSubscription?.[0];
    const articlesPerMonth = subscription?.Package?.articlesPerMonth || 15;

    // Generate topics using AI
    const topicsToGenerate = count || Math.min(30, articlesPerMonth);

    // Get the auto content strategy
    const strategy = await prisma.autoContentStrategy.findUnique({
      where: { clientId: client.id },
    });

    if (!strategy) {
      return NextResponse.json(
        { error: 'No strategy found. Please create a strategy first.' },
        { status: 404 }
      );
    }

    // Call OpenAI to generate topics
    const prompt = `Je bent een content strategist. Genereer ${topicsToGenerate} unieke en interessante onderwerpen voor content in de volgende niche: "${niche}".

${strategy.subTopics.length > 0 ? `Sub-topics om te includeren: ${strategy.subTopics.join(', ')}` : ''}
${strategy.targetAudience ? `Doelgroep: ${strategy.targetAudience}` : ''}

Genereer de onderwerpen in JSON formaat:
[
  {
    "topic": "Exacte titel van het onderwerp",
    "description": "Korte beschrijving (1-2 zinnen)",
    "keywords": ["keyword1", "keyword2", "keyword3"],
    "contentType": "article"
  }
]

Zorg dat de onderwerpen:
- Relevant zijn voor de niche
- Interessant zijn voor de doelgroep
- SEO-vriendelijk zijn
- Actionable zijn (mensen kunnen er iets mee)
- VariÃ«ren in type (how-to, listicles, guides, tips, trends, etc.)`;

    const response = await fetch('https://api.abacus.ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${process.env.ABACUSAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content:
              'Je bent een expert content strategist die helpt met het genereren van relevante en interessante onderwerpen voor content marketing.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.9,
        response_format: { type: 'json_object' },
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to generate topics from AI');
    }

    const aiResponse = await response.json();
    const content = aiResponse.choices[0].message.content;

    let topics;
    try {
      const parsed = JSON.parse(content);
      // Handle both array format and object with topics array
      topics = Array.isArray(parsed) ? parsed : parsed.topics || [];
    } catch (e) {
      console.error('Failed to parse AI response:', content);
      throw new Error('Invalid response format from AI');
    }

    // Save topics to database
    const savedTopics = [];
    for (const topic of topics) {
      const saved = await prisma.autoGeneratedTopic.create({
        data: {
          strategyId: strategy.id,
          topic: topic.topic,
          description: topic.description,
          keywords: topic.keywords || [],
          contentType: topic.contentType || 'article',
          status: 'PENDING',
        },
      });
      savedTopics.push(saved);
    }

    return NextResponse.json({
      success: true,
      topics: savedTopics,
      count: savedTopics.length,
    });
  } catch (error) {
    console.error('Error generating topics:', error);
    return NextResponse.json(
      {
        error:
          error instanceof Error ? error.message : 'Failed to generate topics',
      },
      { status: 500 }
    );
  }
}
